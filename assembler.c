#include <stdio.h>
#include "assembler.h"
#include "parser.h"
#include "utils.h"
#include "functions.h"

#define DEFAULT_HEADER \
    "/* \n" \
    " * Generated by the CLance compiler\n" \
    " * This file is auto-generated\n" \
    " * Compiler version: 1.0\n" \
    " * Date: " __DATE__ " " __TIME__ "\n" \
    " */\n\n"

void program_asm(struct program_node *program, FILE *file,
		 ut_dynamic_array_t instructions_list) {

	program_header(file);
	instructions_functions(file, instructions_list);

	DEBUG("\nAssembling program with %d instructions",
	      program->instructions.len);

	program_asm_loop(program, file, 0);

}

void program_asm_loop(struct program_node *program, FILE *file, int main) {
	for (unsigned int i = 0; i < program->instructions.len; i++) {
		struct instruction_node *instr =
		    ut_array_get(&program->instructions, i);

		if (main == 0 && instr->type != DIRECTIVE_STATEMENT) {
			DEBUG("Found END_STATEMENT, inserting main function");
			fprintf(file, "int main() {\n");
			main = 1;
		}

		instr_asm(instr, file);
	}
}

void program_header(FILE *file) {
	DEBUG("Creating default program header");
	char *header = NULL;
	ut_str_cat(&header, DEFAULT_HEADER, DEFAULT_INCLUDES, NULL);
	fwrite((const void *)header, sizeof(char), strlen(header), file);
	free(header);
	fwrite("\n\n", sizeof(char), 2, file);
	DEBUG("Program header created");
}

void instructions_functions(FILE *file, ut_dynamic_array_t instructions_list) {
	DEBUG("Adding default functions to program, count: %d",
	      instructions_list.len);

	char *funcs_h = NULL;
	char *funcs = NULL;

	for (unsigned int i = 0; i < instructions_list.len; i++) {
		struct instruction_list_element *elem =
		    ut_array_get(&instructions_list, i);
		DEBUG("Processing instruction: %s: %d",
		      show_instruction_type(elem->instruction), elem->type);
		switch (elem->instruction) {
		case INPUT_STATEMENT:{
				switch (elem->type) {
				case INT_TYPE:
					ut_str_cat(&funcs_h, INPUT_INT_HEADER,
						   NULL);
					ut_str_cat(&funcs, INPUT_INT, NULL);
					break;
				case STRING_TYPE:
					ut_str_cat(&funcs_h,
						   INPUT_STRING_HEADER, NULL);
					ut_str_cat(&funcs, INPUT_STRING, NULL);
					break;
				case NULL_TYPE:
				case VOID_TYPE:
				case UNKNOWN_TYPE:
					break;
				}
				break;
			}
			break;
		case INSTRUCTION:
		case ASSIGN:
		case RETURN_STATEMENT:
		case IF_STATEMENT:
		case PRINT_STATEMENT:
		case END_STATEMENT:
		case DIRECTIVE_STATEMENT:
		case TYPE_STATEMENT:
		case EOL_STATEMENT:
			break;
		}
	}

	if (funcs_h != NULL) {
		fwrite((const void *)funcs_h, sizeof(char),
		       strlen(funcs_h), file);
		free(funcs_h);

		fwrite("\n\n", sizeof(char), 2, file);
	}

	if (funcs != NULL) {
		fwrite((const void *)funcs, sizeof(char), strlen(funcs), file);
		free(funcs);
	}

	DEBUG("Default functions added");
}

void instr_asm(struct instruction_node *instr, FILE *f) {
	switch (instr->type) {
	case ASSIGN:
		asm_assign(instr, f);
		break;
	case RETURN_STATEMENT:
		asm_return(instr, f);
		break;
	case IF_STATEMENT:
		asm_if(instr, f);
		break;
	case PRINT_STATEMENT:
		asm_print(instr, f);
		break;
	case END_STATEMENT:
		fwrite("}\n", sizeof(char), 2, f);
		DEBUG("Assembled END_STATEMENT, closing function");
		break;
	case DIRECTIVE_STATEMENT:
		asm_directive(instr, f);
		break;
	case TYPE_STATEMENT:
		asm_type(instr, f);
		break;

	case INSTRUCTION:
	case INPUT_STATEMENT:
	case EOL_STATEMENT:
		break;
	}

}

void asm_directive(struct instruction_node *instr, FILE *f) {
	if (instr->directive_statement.identifier == NULL) {
		ERROR(1, "Directive identifier is NULL");
	}
	DEBUG("Assembling directive: %s",
	      instr->directive_statement.identifier);

	char *directive = NULL;
	// TODO separate identifier and value
	ut_str_cat(&directive, "#", instr->directive_statement.identifier,
		   NULL);

	fwrite((const void *)directive, sizeof(char), strlen(directive), f);

	fwrite("\n\n", sizeof(char), 2, f);

	DEBUG("Assembled directive: %s", directive);
	free(directive);
}

void asm_print(struct instruction_node *instr, FILE *f) {
	switch (instr->print_statement.term.type) {
	case INPUT_TERM:
		break;
	case INT_TERM:
		if (instr->print_statement.term.value == NULL) {
			ERROR(1, "INT_TERM value is NULL");
		}
		fprintf(f, "printf(\"%%d\\n\", %s);\n",
			instr->print_statement.term.value);
		break;
	case IDENTIFIER_TERM:
		break;
	case STRING_TERM:
		if (instr->print_statement.term.value == NULL) {
			ERROR(1, "STRING_TERM value is NULL");
		}
		fprintf(f, "printf(\"%s\");\n",
			instr->print_statement.term.value);
		break;
	}
}

void asm_type(struct instruction_node *instr, FILE *f) {
	switch (instr->type_statement.type) {
	case INT_TYPE:{
			fwrite("int ", sizeof(char), 4, f);
			asm_assign(instr, f);
			break;
		}
	case STRING_TYPE:
		break;
	case VOID_TYPE:
		break;
	default:
		ERROR(1, "Unknown type: %d", instr->type_statement.type);
	}
}

void asm_assign(struct instruction_node *instr, FILE *f) {
	if (instr->assign.identifier == NULL) {
		ERROR(1, "Assign identifier is NULL");
	}

	switch (instr->assign.expression.type) {
	case INPUT_EXPRESSION:
		if (instr->assign.identifier == NULL) {
			ERROR(1, "Assign identifier is NULL");
		}

		char *prompt = instr->assign.expression.input.prompt;
		if (prompt == NULL) {
			ERROR(1, "Input prompt is NULL for Assign");
		}

		fprintf(f, "%s = ", instr->assign.identifier);

		fprintf(f, INPUT_INT_CALLER_FMT, prompt);

		break;
	case TERM_EXPRESSION:
		if (instr->assign.expression.term.value == NULL) {
			ERROR(1, "TERM_EXPRESSION value is NULL");
		}
		fprintf(f, "%s = %s;\n", instr->assign.identifier,
			instr->assign.expression.term.value);
		break;
	case PLUS_EXPRESSION:
		if (instr->assign.expression.add.left.value == NULL ||
		    instr->assign.expression.add.right.value == NULL) {
			ERROR(1, "PLUS_EXPRESSION values are NULL");
		}
		fprintf(f, "%s = %s + %s;\n", instr->assign.identifier,
			instr->assign.expression.add.left.value,
			instr->assign.expression.add.right.value);
		break;
	default:
		ERROR(1, "Unknown expression type: %d",
		      instr->assign.expression.type);
	}
}

void asm_if(struct instruction_node *instr, FILE *f) {

	switch (instr->if_statement.rel.type) {

	case GREATER_THAN_RELATION:{
			if (instr->if_statement.rel.greater_than.left.value ==
			    NULL
			    || instr->if_statement.rel.greater_than.right.
			    value == NULL) {
				ERROR(1,
				      "GREATER_THAN_RELATION values are NULL");
			}
			fprintf(f, "if (%s > %s) {\n",
				instr->if_statement.rel.greater_than.left.value,
				instr->if_statement.rel.greater_than.right.
				value);
			if (instr->if_statement.body != NULL
			    && instr->if_statement.body->instructions.len > 0) {
				program_asm_loop(instr->if_statement.body, f,
						 1);
			}
			break;
		}
	}
}

void asm_return(struct instruction_node *instr, FILE *f) {
	switch (instr->return_statement.expression.type) {

	case TERM_EXPRESSION:
		if (instr->return_statement.expression.term.value == NULL) {
			ERROR(1, "TERM_EXPRESSION value is NULL");
		}
		fprintf(f, "return %s;\n",
			instr->return_statement.expression.term.value);
		break;
	case PLUS_EXPRESSION:
		if (instr->return_statement.expression.add.left.value == NULL ||
		    instr->return_statement.expression.add.right.value ==
		    NULL) {
			ERROR(1, "PLUS_EXPRESSION values are NULL");
		}
		fprintf(f, "return %s + %s;\n",
			instr->return_statement.expression.add.left.value,
			instr->return_statement.expression.add.right.value);
		break;
	case INPUT_EXPRESSION:
		break;
	}
}
