#include "assembler.h"
#include "parser.h"
#include "utils.h"
#include <stdio.h>

#define DEFAULT_HEADER \
    "/* \n" \
    " * Generated by the CLance compiler\n" \
    " * This file is auto-generated\n" \
    " * Compiler version: 1.0\n" \
    " * Date: " __DATE__ " " __TIME__ "\n" \
    " */\n\n"

#define DEFAULT_INCLUDES \
    "#include <stdio.h>\n" \
				// "#include <stdlib.h>\n" \
    // "#include <string.h>"

void program_asm(struct program_node *program, FILE *file) {

	DEBUG("Creating default program header");
	char *header = NULL;
	ut_str_cat(&header, DEFAULT_HEADER, DEFAULT_INCLUDES, NULL);
	fwrite((const void *)header, sizeof(char), strlen(header), file);
	free(header);
	fwrite("\n\n", sizeof(char), 2, file);
	DEBUG("Program header created");

	DEBUG("Assembling program with %d instructions",
	      program->instructions.len);

	int main = 0;
	for (unsigned int i = 0; i < program->instructions.len; i++) {
		struct instruction_node *instr =
		    ut_array_get(&program->instructions, i);

		if (main == 0 && instr->type != DIRECTIVE_STATEMENT) {
			DEBUG("Found END_STATEMENT, inserting main function");
			fprintf(file, "int main() {\n");
			main = 1;
		}

		instr_asm(instr, file);
	}

	if (main == 1) {
		fprintf(file, "return 0;\n}\n");
		DEBUG("Inserted main function end");
	} else {
		DEBUG("No END_STATEMENT found, not inserting main function");
	}
}

void instr_asm(struct instruction_node *instr, FILE *f) {
	switch (instr->type) {
	case INSTRUCTION:
		break;
	case ASSIGN:
    asm_assign(instr, f);
		break;
	case RETURN_STATEMENT:
		break;
	case IF_STATEMENT:
		break;
	case PRINT_STATEMENT:
		asm_print(instr, f);
		break;
	case INPUT_STATEMENT:
		break;
	case END_STATEMENT:
		break;
	case DIRECTIVE_STATEMENT:
		asm_directive(instr, f);
		break;
	case TYPE_STATEMENT:
		asm_type(instr, f);
		break;
	case EOL_STATEMENT:
		break;
	}

}

void asm_directive(struct instruction_node *instr, FILE *f) {
	if (instr->directive_statement.identifier == NULL) {
		ERROR(1, "Directive identifier is NULL");
	}
	DEBUG("Assembling directive: %s",
	      instr->directive_statement.identifier);

	char *directive = NULL;
	// TODO separate identifier and value
	ut_str_cat(&directive, "#", instr->directive_statement.identifier,
		   NULL);

	fwrite((const void *)directive, sizeof(char), strlen(directive), f);

	fwrite("\n\n", sizeof(char), 2, f);

	DEBUG("Assembled directive: %s", directive);
	free(directive);
}

void asm_print(struct instruction_node *instr, FILE *f) {
	switch (instr->print_statement.term.type) {
	case INPUT_TERM:
		break;
	case INT_TERM:
		if (instr->print_statement.term.value == NULL) {
			ERROR(1, "INT_TERM value is NULL");
		}
		fprintf(f, "printf(\"%%d\", %s);\n",
			instr->print_statement.term.value);
		break;
	case IDENTIFIER_TERM:
		break;
	case STRING_TERM:
		if (instr->print_statement.term.value == NULL) {
			ERROR(1, "STRING_TERM value is NULL");
		}
		fprintf(f, "printf(\"%s\");\n",
			instr->print_statement.term.value);
		break;
	}
}

void asm_type(struct instruction_node *instr, FILE *f) {
	switch (instr->type_statement.type) {
	case INT_TYPE:{
			if (instr->assign.expression.type == INPUT_EXPRESSION) {
				if (instr->assign.identifier == NULL) {
					ERROR(1, "INT_TYPE identifier is NULL");
				}
				fprintf(f, "int %s;\n",
					instr->assign.identifier);

				char *prompt =
				    instr->assign.expression.input.prompt;
				if (prompt == NULL) {
					ERROR(1,
					      "Input prompt is NULL for INT_TYPE");
				}
				fprintf(f, "printf(\"%s\");\n", prompt);
				fprintf(f, "scanf(\"%%d\", &%s);\n",
					instr->assign.identifier);
			} else if (instr->assign.expression.type ==
				   TERM_EXPRESSION) {
				fprintf(f, "int %s = %s;\n",
					instr->assign.identifier,
					instr->assign.expression.term.value);
			} else if (instr->assign.expression.type ==
                    PLUS_EXPRESSION) {
                fprintf(f, "int %s = %s + %s;\n",
                    instr->assign.identifier,
                    instr->assign.expression.add.left.value,
                    instr->assign.expression.add.right.value);
            } else {
                ERROR(1, "Unknown expression type for INT_TYPE");
            }

			break;
		}
	case STRING_TYPE:
		break;
	case VOID_TYPE:
		break;
	default:
		ERROR(1, "Unknown type: %d", instr->type_statement.type);
	}
}

void asm_assign(struct instruction_node *instr, FILE *f) {
    if (instr->assign.identifier == NULL) {
        ERROR(1, "Assign identifier is NULL");
    }

    switch (instr->assign.expression.type) {
    case INPUT_EXPRESSION:
        fprintf(f, "scanf(\"%%d\", &%s);\n",
            instr->assign.identifier);
        break;
    case TERM_EXPRESSION:
        if (instr->assign.expression.term.value == NULL) {
            ERROR(1, "TERM_EXPRESSION value is NULL");
        }
        fprintf(f, "%s = %s;\n", instr->assign.identifier,
            instr->assign.expression.term.value);
        break;
    case PLUS_EXPRESSION:
        if (instr->assign.expression.add.left.value == NULL ||
            instr->assign.expression.add.right.value == NULL) {
            ERROR(1, "PLUS_EXPRESSION values are NULL");
        }
        fprintf(f, "%s = %s + %s;\n", instr->assign.identifier,
            instr->assign.expression.add.left.value,
            instr->assign.expression.add.right.value);
        break;
    default:
        ERROR(1, "Unknown expression type: %d",
              instr->assign.expression.type);
    }
}